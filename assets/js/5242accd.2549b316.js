"use strict";(self.webpackChunkPCB_Design=self.webpackChunkPCB_Design||[]).push([[945],{4287:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"projects/project-esp32/layout","title":"PCB Layout","description":"The PCB layout phase is where the schematic design is translated into a physical board. This involves placing components, routing traces, and ensuring that the design meets electrical and mechanical requirements. In this chapter, we will walk through the process of designing the PCB layout for the ESP32-based IoT device in KiCad 7.","source":"@site/docs/09_projects/04_project-esp32/04_layout.md","sourceDirName":"09_projects/04_project-esp32","slug":"/projects/project-esp32/layout","permalink":"/PCB-Design-with-KiCad/docs/projects/project-esp32/layout","draft":false,"unlisted":false,"editUrl":"https://github.com/CagriCatik/PCB-Design-with-KiCad/docs/09_projects/04_project-esp32/04_layout.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"projectsSidebar","previous":{"title":"Schematic Design","permalink":"/PCB-Design-with-KiCad/docs/projects/project-esp32/schematic"},"next":{"title":"Design Rule Check (DRC) and Final Checks","permalink":"/PCB-Design-with-KiCad/docs/projects/project-esp32/drc"}}');var t=i(4848),r=i(8453);const l={},o="PCB Layout",c={},a=[{value:"Setting Up the PCB Layout",id:"setting-up-the-pcb-layout",level:2},{value:"Placing Components",id:"placing-components",level:2},{value:"Routing the PCB",id:"routing-the-pcb",level:2},{value:"Design Rule Check (DRC)",id:"design-rule-check-drc",level:2},{value:"Finalizing the PCB Layout",id:"finalizing-the-pcb-layout",level:2},{value:"Summary",id:"summary",level:2}];function h(e){const n={h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pcb-layout",children:"PCB Layout"})}),"\n",(0,t.jsx)(n.p,{children:"The PCB layout phase is where the schematic design is translated into a physical board. This involves placing components, routing traces, and ensuring that the design meets electrical and mechanical requirements. In this chapter, we will walk through the process of designing the PCB layout for the ESP32-based IoT device in KiCad 7."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"setting-up-the-pcb-layout",children:"Setting Up the PCB Layout"}),"\n",(0,t.jsx)(n.p,{children:"Before placing components and routing traces, it\u2019s important to configure the PCB layout environment."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Open the PCB Editor:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In the KiCad Project Manager, double-click on the IoT_Thing.kicad_pcb file to open the PCB Editor."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Define the Board Outline:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Switch to the Edge.Cuts layer."}),"\n",(0,t.jsx)(n.li,{children:"Use the Draw Line tool to create a rectangle that defines the board outline (80mm x 80mm)."}),"\n",(0,t.jsx)(n.li,{children:"Add rounded corners using the Draw Arc tool for a professional look."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Set Up the Layer Stack:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Go to Board Setup > Physical Stackup."}),"\n",(0,t.jsxs)(n.li,{children:["Configure the board as a 4-layer PCB:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Top Layer: Signal routing and component placement."}),"\n",(0,t.jsx)(n.li,{children:"Inner Layer 1: Ground plane."}),"\n",(0,t.jsx)(n.li,{children:"Inner Layer 2: Power plane."}),"\n",(0,t.jsx)(n.li,{children:"Bottom Layer: Signal routing and additional components."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Import Components:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use the Update PCB from Schematic tool to import all components and their connections into the PCB layout."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"placing-components",children:"Placing Components"}),"\n",(0,t.jsx)(n.p,{children:"Proper component placement is critical for signal integrity, thermal management, and manufacturability."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"ESP32 WROOM Module:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place the ESP32 module near the center of the board."}),"\n",(0,t.jsx)(n.li,{children:"Ensure the antenna area is clear of other components and traces."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"USB-C Connector and CP2104:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place the USB-C connector near the edge of the board for easy access."}),"\n",(0,t.jsx)(n.li,{children:"Position the CP2104 USB-to-Serial converter close to the USB connector."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"SI7021 Sensor and Quick Connector:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place the SI7021 sensor and quick connector in a location that minimizes trace lengths for the I\xb2C bus."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Relay and Screw Terminals:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place the relay and screw terminals near the edge of the board for easy access to external connections."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Level Converters and LED Strip Interface:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place the 74HCT245 level shifter and LED strip interface near the ESP32 GPIO pins."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Power Supply Components:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place the LDO (TLV1117LV-3.3V), decoupling capacitors, and fuse near the power input."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Mounting Holes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Place mounting holes in each corner of the board, ensuring they are aligned with the board outline."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"routing-the-pcb",children:"Routing the PCB"}),"\n",(0,t.jsx)(n.p,{children:"Routing involves connecting the components with copper traces while adhering to design rules and best practices."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Critical Signal Routing:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Start with the most critical signals, such as the USB data lines and I\xb2C bus."}),"\n",(0,t.jsx)(n.li,{children:"Use differential pairs for USB signals to minimize noise and ensure signal integrity."}),"\n",(0,t.jsx)(n.li,{children:"Keep I\xb2C traces short and add pull-up resistors close to the ESP32."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Power and Ground Routing:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use wide traces for power and ground connections to minimize resistance and voltage drop."}),"\n",(0,t.jsx)(n.li,{children:"Connect the ground pins of all components to the ground plane using vias."}),"\n",(0,t.jsx)(n.li,{children:"Route the 3.3V and 5V power nets using the power plane where possible."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Signal Routing:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Route the GPIO signals to the level shifter, RGB LED, and relay."}),"\n",(0,t.jsx)(n.li,{children:"Use 45-degree angles for traces to reduce electromagnetic interference (EMI)."}),"\n",(0,t.jsx)(n.li,{children:"Avoid crossing traces on the same layer by using vias to switch layers."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Copper Pour and Ground Plane:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Add a copper pour on the top and bottom layers, connected to the ground net."}),"\n",(0,t.jsx)(n.li,{children:"Ensure the ground plane is continuous and free of unnecessary splits."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"design-rule-check-drc",children:"Design Rule Check (DRC)"}),"\n",(0,t.jsx)(n.p,{children:"The Design Rule Check ensures that the PCB layout adheres to the specified design rules."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Run the DRC:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Go to Inspect > Design Rule Checker."}),"\n",(0,t.jsx)(n.li,{children:"Check for errors such as clearance violations, unconnected nets, and incorrect trace widths."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Fix Errors:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Address any errors or warnings identified by the DRC."}),"\n",(0,t.jsx)(n.li,{children:"Re-run the DRC until no errors are found."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"finalizing-the-pcb-layout",children:"Finalizing the PCB Layout"}),"\n",(0,t.jsx)(n.p,{children:"Before generating manufacturing files, perform a final review of the PCB layout."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Add Silkscreen Labels:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use the Place Text tool to add labels for components, connectors, and test points."}),"\n",(0,t.jsx)(n.li,{children:"Ensure the labels are clear and do not overlap with pads or vias."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"3D Visualization:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use the 3D Viewer to inspect the PCB layout in 3D."}),"\n",(0,t.jsx)(n.li,{children:"Check for component placement, mechanical clearances, and overall aesthetics."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Generate Manufacturing Files:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Go to File > Plot to generate Gerber files for all layers."}),"\n",(0,t.jsx)(n.li,{children:"Generate drill files for plated and non-plated holes."}),"\n",(0,t.jsx)(n.li,{children:"Create a ZIP file containing all manufacturing files."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we designed the PCB layout for the ESP32-based IoT device. We placed components, routed traces, and performed a Design Rule Check to ensure the layout meets all requirements. The PCB layout is now ready for manufacturing, bringing the schematic design to life as a physical board. In the next chapter, we will cover the final steps of generating manufacturing files and preparing the design for production."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"This chapter provides a comprehensive guide to PCB layout in KiCad, covering everything from component placement to finalizing the design. By following these steps, you\u2019ll create a professional and functional PCB layout that is ready for manufacturing."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);